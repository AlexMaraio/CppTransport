//
// Created by David Seery on 22/12/2015.
// --@@
// Copyright (c) 2016 University of Sussex. All rights reserved.
//
// This file is part of the CppTransport platform.
//
// CppTransport is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// CppTransport is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with CppTransport.  If not, see <http://www.gnu.org/licenses/>.
//
// @license: GPL-2
// @contributor: David Seery <D.Seery@sussex.ac.uk>
// --@@
//


#include <sstream>

#include "lambdas.h"

#include "cse.h"
#include "language_printer.h"


generic_lambda::generic_lambda(const abstract_index_database& list, expression_item_types t, const ginac_cache_tags& tg, std::string ty)
  : index_list(list),
    type(t),
    tags(tg),
    working_type(std::move(ty))
  {
  }


generic_lambda::generic_lambda(const abstract_index& i, expression_item_types t, const ginac_cache_tags& tg, std::string ty)
  : type(t),
    tags(tg),
    working_type(std::move(ty))
  {
    index_list.emplace_back(std::make_pair(i.get_label(), std::make_shared<abstract_index>(i)));
  }


generic_lambda::generic_lambda(const abstract_index& i, const abstract_index& j, expression_item_types t, const ginac_cache_tags& tg, std::string ty)
  : type(t),
    tags(tg),
    working_type(std::move(ty))
  {
    index_list.emplace_back(std::make_pair(i.get_label(), std::make_shared<abstract_index>(i)));
    index_list.emplace_back(std::make_pair(j.get_label(), std::make_shared<abstract_index>(j)));
  }


generic_lambda::generic_lambda(const abstract_index& i, const abstract_index& j, const abstract_index& k, expression_item_types t, const ginac_cache_tags& tg, std::string ty)
  : type(t),
    tags(tg),
    working_type(std::move(ty))
  {
    index_list.emplace_back(std::make_pair(i.get_label(), std::make_shared<abstract_index>(i)));
    index_list.emplace_back(std::make_pair(j.get_label(), std::make_shared<abstract_index>(j)));
    index_list.emplace_back(std::make_pair(k.get_label(), std::make_shared<abstract_index>(k)));
  }


std::unique_ptr< std::list<std::string> >
atomic_lambda::make_temporary(const std::string& left, const std::string& mid, const std::string& right,
                              language_printer& printer, cse& cse_worker, unsigned int num_fields) const
  {
    auto rval = std::make_unique< std::list<std::string> >();

    std::string open = printer.open_lambda(this->index_list, this->working_type);
    std::string close = printer.close_lambda();

    auto block_indent = printer.get_block_indent();
    auto block_spacing = std::string(block_indent, ' ');

    // perform CSE (no-op if CSE has been disabled)
    cse_worker.parse(this->expr);
    std::string ex = cse_worker.get_symbol_with_use_count(this->expr);

    // get temporaries generated by CSE
    auto temps = cse_worker.temporaries(left, mid, right);

    if(!temps || temps->empty())
      {
        std::ostringstream stmt;
        stmt << open << " " << printer.format_return(ex) << " " << close;
        rval->push_back(stmt.str());
      }
    else
      {
        rval->push_back(open);
        for(const auto& s : *temps) rval->push_back(block_spacing + s);
        rval->push_back(block_spacing + printer.format_return(ex));
        rval->push_back(close);
      }

    // reset CSE worker
    cse_worker.clear();

    return rval;
  }


std::unique_ptr< std::list<std::string> >
map_lambda::make_temporary(const std::string& left, const std::string& mid, const std::string& right,
                           language_printer& printer, cse& cse_worker, unsigned int num_fields) const
  {

    std::string open = printer.open_lambda(this->index_list, this->working_type);
    std::string close = printer.close_lambda();

    // can assume that the cached map is a suitable size for the supplied index list,
    // since this was checked during construction

    auto rval = std::make_unique< std::list<std::string> >();

    auto block_indent = printer.get_block_indent();
    auto delimiter_indent = printer.get_block_delimiter_indent();
    auto block_spacing = std::string(block_indent, ' ');
    auto delimiter_spacing = std::string(delimiter_indent, ' ');

    auto start_block = printer.get_start_block_delimiter();
    auto end_block = printer.get_end_block_delimiter();

    rval->push_back(open);

    // get temporaries generated by CSE
    auto temps = cse_worker.temporaries(left, mid, right);
    if(!temps->empty()) rval->splice(rval->end(), *temps);

    unsigned int counter = 0;
    for(const auto& expr : this->map)
      {
        std::list< GiNaC::ex > conditions;
        unsigned int state = counter;

        // work through index list in reverse order, assuming this is the order given by the lambda_flatten() functions
        // calculate the appropriate conditions for this index assignment from the current position in the map, and push them to the list
        for(abstract_index_database::const_reverse_iterator t = this->index_list.crbegin(); t != this->index_list.crend(); ++t)
          {
            GiNaC::symbol sym(t->get_loop_variable());
            GiNaC::ex rel = state % 2 == 1 ? sym >= num_fields : sym < num_fields;
            conditions.push_back(rel);
            state = state / 2;
          }

        // perform CSE (no-op if CSE has been disabled)
        // (note, we have to perform CSE on a case-by-case basis, otherwise we can end up indexing
        // arrays using subscripts that are out-of-bounds, because the subscripts that are used
        // are special to each case
        cse_worker.parse(expr);
        std::string ex = cse_worker.get_symbol_with_use_count(expr);

        // get temporaries generated by CSE
        auto temps = cse_worker.temporaries(left, mid, right);

        // emit code for this case
        // each case can be a separate 'if' statement since the function exits whenever one is executed
        if(!temps || temps->empty())
          {
            rval->push_back(block_spacing + printer.format_if(conditions) + " " + printer.format_return(ex));
          }
        else
          {
            rval->push_back(block_spacing + printer.format_if(conditions));
            if(start_block) rval->push_back(block_spacing + delimiter_spacing + *start_block);
            for(const auto& s : *temps) rval->push_back(block_spacing + block_spacing + s);
            rval->push_back(block_spacing + block_spacing + printer.format_return(ex));
            if(end_block) rval->push_back(block_spacing + delimiter_spacing + *end_block);
          }

        ++counter;

        // reset CSE worker
        cse_worker.clear();
      }

    // kill compiler warning about possible void return
    GiNaC::ex null_value = 0;
    rval->push_back(block_spacing + printer.format_return(null_value));

    rval->push_back(close);

    return rval;
  }
