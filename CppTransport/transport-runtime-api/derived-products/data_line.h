//
// Created by David Seery on 21/05/2014.
// Copyright (c) 2014 University of Sussex. All rights reserved.
//


#ifndef __data_line_H_
#define __data_line_H_

#include <vector>
#include <string>

#include "transport-runtime-api/messages.h"
#include "transport-runtime-api/exceptions.h"


namespace transport
  {

    namespace derived_data
      {


        //! A data_line is a data line suitable for use by a derived output.
        //! data_lines are generated by the different content generators, eg field_time_data etc.

        template <typename number>
        class data_line
          {

          public:

		        typedef enum { time_series, wavenumber_series, angle_series, squeezing_fraction } axis_type;

		        typedef enum { background_field, correlation_function, fNL, r, spectral_index } value_type;

          public:

		        //! Construct a dataline object from a sequence of axis and data points
            data_line(axis_type at, value_type vt, const std::vector<double> a, const std::vector<number> d, const std::string& Ll, const std::string& nLl);

            ~data_line() = default;


            // GET DATA

            //! Get number of sample points
            unsigned int size() const { return(this->data.size()); }

            //! Get LaTeX label
            const std::string& get_LaTeX_label() const { return(this->LaTeX_label); }

		        //! Get non-LaTeX label
		        const std::string& get_non_LaTeX_label() const { return(this->non_LaTeX_label); }

		        //! Get data points
		        const std::vector< std::pair<double, number> >& get_data_points() const { return(this->data); }

		        //! Get axis type
		        axis_type get_axis_type() const { return(this->x_type); }

		        //! Get value type
		        value_type get_value_type() const { return(this->y_type); }


            // INTERNAL DATA

		        //! axis type
		        const axis_type x_type;

		        //! value type
		        const value_type y_type;

		        std::vector< std::pair<double, number> > data;

            //! non-LaTeX label
            const std::string LaTeX_label;

		        //! non-LaTeX label
						const std::string non_LaTeX_label;
          };


        template <typename number>
        data_line<number>::data_line(typename data_line<number>::axis_type at, typename data_line<number>::value_type vt,
                                     const std::vector<double> a, const std::vector<number> d,
                                     const std::string& Ll, const std::string& nLl)
	        : x_type(at), y_type(vt), LaTeX_label(Ll), non_LaTeX_label(nLl)
	        {
            if(a.size() != d.size())
	            throw runtime_exception(runtime_exception::RUNTIME_ERROR, __CPP_TRANSPORT_PRODUCT_DATALINE_AXIS_MISMATCH);

            data.reserve(a.size());

            // push data points onto the axis
            for(unsigned int i = 0; i < a.size(); i++)
	            {
                data.push_back(std::make_pair(a[i], d[i]));
	            }

            // now sort axis into ascending order
            struct AxisSorter
	            {
                bool operator()(const std::pair<double, number>& a, const std::pair<double, number>& b)
	                {
                    return (a.first < b.first);
	                }
	            };

            sort(data.begin(), data.end(), AxisSorter());
	        }


	    }   // namespace derived_data

  }   // namespace transport


#endif //__data_line_H_
