//
// Created by David Seery on 07/05/2014.
// Copyright (c) 2014 University of Sussex. All rights reserved.
//


#ifndef __json_serialization_stack_H_
#define __json_serialization_stack_H_


#include <string>
#include <list>
#include <functional>
#include <utility>

#include "transport-runtime-api/exceptions.h"
#include "transport-runtime-api/messages.h"

#include "boost/lexical_cast.hpp"


#define __CPP_TRANSPORT_JSON_ATTRIBUTE_TAG "@@@"
#define __CPP_TRANSPORT_JSON_ROOT_NODE     "root"


//#define __CPP_TRANSPORT_JSON_DEBUG


namespace transport
	{

    //! implements an serialization stack, which can be the basis of
    //! either a serialization_writer or serialization_reader interface.

    class json_serialization_stack
	    {
      protected:

        // set up an abstract class hierarchy representing the
        // elements of which the serialization is composed.
        // 'element' is the basic abstract type
        //   'nodes' are elements which may have attributes and contents. It is an abstract type
        //     'user_node' is the typical node generated by a class performing serialization.
        //     'root_node' is a special node type representing the base of a serialization tree.
        //       they can be the base for the entire serialization, or the elements in an array
        //       root nodes stringize slightly differently, but are otherwise the same as user_nodes
        //   'value_element' is a container for some value type

        //! When pulling from the stack, need a tag to describe what type of
        //! data is expected. Elements can accept or decline a pull based on the
        //! type of data being asked for
        typedef enum { value, node, array } element_type;

        //! element: most general object which can be in the serialization tree
        class element
	        {
          public:
            //! Constructor, specified name
            element(const std::string& nm)
	            : name(nm), read(false)
	            {
	            }

            //! Create a virtual destructor to ensure destructors for derived classes get called
            virtual ~element()
	            {
	            }

            //! Get name
            const std::string& get_name() { return(this->name); }

            //! Mark this item as unread.
            //! May be overridden by derived classes which contain extra data,
            //! eg. nodes or arrays
            virtual void set_unread() { this->read = false; }

            //! Enquire whether this element will accept a pull request with a specified field name
            //! This should be implemented by a derived class.
            virtual bool pull_enquiry(element_type pull_type, const std::string& pull_name) = 0;

		        //! Enquire whether this element will accept a pull request, with no name specified
		        //! This should be implemented by the derived class.
		        //! It is used by arrays to pick out elements, since in arrays there is no concept of a name.
		        virtual bool pull_enquiry(element_type pull_type) = 0;

            //! 'attribute' marks that this element is an attribute
            //! it's up to the attribute element whether it uses this information
            //! at present, it is used to map XML-style attributes
            //! to a '@' tag for JSON fields
            virtual std::string stringize(bool attribute=false) const = 0;

            //! Self-validate -- used when ending a node
            virtual bool validate() const = 0;

          protected:

		        //! Get read status of this element
		        bool get_read() { return(this->read); }

		        //! Mark this element as read
		        void set_read() { this->read = true; }

          protected:

            //! Name of this element
            std::string name;

            //! Has this element been read? Used when pulling items off the stack
            bool read;
	        };


        //! basic_node: most general container type in the serialization tree.
        //! specializations are named or unnamed nodes, or arrays
        class basic_node: public element
	        {
          public:

            //! Constructor with specified name and empty state.
            basic_node(const std::string& nm, bool emp=false)
	            : empty(emp), element(nm)
	            {
	            }

            //! Declare virtual destructor so destructors of derived classes get called.
		        //! We also have to delete all the elements.
            virtual ~basic_node()
	            {
		            for(std::list<element*>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
			            {
				            delete (*t);
			            }
		            for(std::list<element*>::iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
			            {
				            delete (*t);
			            }
	            }

            //! Mark this item as unread. Over-rides implementation in 'element', because
            //! we recursively set the read-state of our attributes and contents.
            virtual void set_unread() override;

            //! Derived classes should implement a method to make a new contents element,
            //! suitable for storage within this node. What this should be can vary depending whether the node is an array,
            //! a user_node or a root_node
            virtual basic_node* make_element(const std::string& name, bool empty=false) = 0;

            //! Push an element to our contents.
		        //! Any element with the same name is removed, because it is assume this push
		        //! is an attempt to update.
            virtual void push_content(element* ele, bool is_insert);

            //! Push an element to our attributes.
            void push_attribute(element* ele, bool is_insert);

		        //! Get number of content elements
		        unsigned int get_num_contents() { return(this->contents.size()); }

		        //! Get number of attribute elements
		        unsigned int get_num_attributes() { return(this->attributes.size()); }

            //! Enquire whether this node can service a request to pull some particular content.
		        //! Returns false if it cannot.
            //! Otherwise, returns true and writes the pulled element into the supplied reference.
            bool pull_content(element_type pull_type, const std::string& name, element*& ele);

            //! Enquire whether this node can service a request to pull a particular named attribute.
		        //! Returns false if it cannot.
            //! Otherwise, returns true and writes the pulled element into the supplied reference.
            bool pull_attribute(element_type pull_type, const std::string& name, element*& ele);

		        //! Merge two nodes. The contents of the second node are erased.
		        void merge(basic_node* other_node);


          protected:

            //! true = this node is empty, or should be empty. Used during validation.
            bool empty;

            //! list of elements representing attributes
            std::list<element*> attributes;

            //! list of elements representing the contents of this node
            std::list<element*> contents;
	        };


        class user_node: public basic_node
	        {
          public:

            //! Constructor with specified name and empty state
            user_node(const std::string& nm, bool emp=false)
	            : basic_node(nm, emp)
	            {
	            }

            //! Stringize this user_node for serialization to JSON
            virtual std::string stringize(bool attribute=false) const override;

            //! Self-validate. Here, we need only check that if empty, we have no contents
            virtual bool validate() const override;

            //! Override base_node function to make a new contents element suitable for storage in this node.
            //! For a user_array, this should be a root_node
            virtual basic_node* make_element(const std::string& name, bool empty=false) override;

		        //! Override element function to service a named pull enquiry
            virtual bool pull_enquiry(element_type pull_type, const std::string& pull_name) override;

		        //! Override element function to service a nameless pull enquiry
		        virtual bool pull_enquiry(element_type pull_type) override;

	        };


        class user_array: public basic_node
	        {
          public:

            //! Constructor with specified name and empty state
            user_array(const std::string& nm, bool emp=false)
	            : basic_node(nm, emp)
	            {
	            }

		        //! Override default push_content() method. For arrays, we don't want
		        //! to over-write elements with the same name
		        virtual void push_content(element* ele, bool is_insert) override;

            //! Stringize this user_array for serialization to JSON
            virtual std::string stringize(bool attribute=false) const override;

		        //! Self-validate. Here, we should check that if we are supposed to be empty we have no content.
            virtual bool validate() const override;

            //! Override basic_node function to make a new contents element suitable for storage in this node.
            //! For a user_array, this should be a root_node
            virtual basic_node* make_element(const std::string& name, bool empty=false) override;

		        //! Override element function to service a named pull enquiry
            virtual bool pull_enquiry(element_type pull_type, const std::string& pull_name) override;

		        //! Override element function to service a nameless pull enquiry
		        virtual bool pull_enquiry(element_type pull_type) override;

		        //! Can't pull content from an array, only elements, so delete the pull_content() method we inherit.
		        bool pull_content(element_type pull_type, const std::string& name, element*& ele) = delete;

		        //! Instead of pulling content, we have to pull elmenets
		        bool pull_element(element*& ele);
	        };


        class root_node: public basic_node
	        {
          public:

            //! Constructor with specified name and empty state
            root_node(const std::string& nm, bool emp=false)
	            : basic_node(nm, emp)
	            {
	            }

            //! Stringize this root_node for serialization to JSON.
            //! root_node stringizes like user_node, except that we don't generate a field name and a value,
            //! only a group of JSON fields surrounded by { ... }
            virtual std::string stringize(bool attribute=false) const override;

            //! Self-validate. Here, as for a user_node, we need only check that if empty, we have no contents
            virtual bool validate() const override;

            //! Make a new contents element. For us, this should be a user-node
            virtual basic_node* make_element(const std::string& name, bool empty=false) override;

            //! Override element function to service a named pull enquiry
            virtual bool pull_enquiry(element_type pull_type, const std::string& pull_name) override;

		        //! Override element function to service a nameless pull enquiry
		        virtual bool pull_enquiry(element_type pull_type) override;
	        };


		    class basic_value_element: public element
			    {
		      public:

				    //! Constructor with specified name
				    basic_value_element(const std::string& nm)
				      : element(nm)
					    {
					    }

				    //! Virtual destructor
				    virtual ~basic_value_element()
					    {
					    }

		        //! Convert content to different representations, if possible
		        virtual std::string  get_string() const = 0;
		        virtual unsigned int get_unsigned_int() const = 0;
		        virtual double       get_double() const = 0;
		        virtual bool         get_bool() const = 0;
			    };


        template <typename T>
        class value_element: public basic_value_element
	        {
          public:

            //! Constructor with specified name and stored value
            value_element(const std::string& nm, const T& val)
	            : value(val), basic_value_element(nm)
	            {
	            }

            //! Get value
            const T& get_value() { return(this->value); }

            //! Stringize the value stored in this element for serialization to JSON.
            virtual std::string stringize(bool attribute=false) const override;

            //! Self-validate. For value_element there is nothing to do.
            virtual bool validate() const override { return(true); }

            //! Override element function to service a named pull enquiry
            virtual bool pull_enquiry(element_type pull_type, const std::string& pull_name) override;

		        //! OVerride element function to service a nameless pull enquiry
		        virtual bool pull_enquiry(element_type pull_type) override;

		        //! Convert content to different representations, if possible.
		        //! Implements the basic_value_element conversion interface.
		        std::string  get_string()       const override { return(boost::lexical_cast<std::string>(this->value)); }
            unsigned int get_unsigned_int() const override { return(boost::lexical_cast<unsigned int>(this->value)); }
            double       get_double()       const override { return(boost::lexical_cast<double>(this->value)); }
            bool         get_bool()         const override { return(boost::lexical_cast<bool>(this->value)); }

          protected:

		        //! Convert value to string for JSON output.
		        //! Partly done this way because string values need to be quoted.
            std::string to_string(const std::string& v) const;
		        std::string to_string(const unsigned int& v) const;
		        std::string to_string(const double& v) const;
		        std::string to_string(const bool& v) const;

          protected:

            //! Stored value
            T value;
	        };


      public:

        //! create an json_serialization_stack

        json_serialization_stack()
	        {
		        root = new root_node(__CPP_TRANSPORT_JSON_ROOT_NODE, false);

            // push the root node onto the stack
            this->node_stack.push_front(this->root);

		        // push the root node as the first bookmark
		        this->bookmarks.push_front(this->root);
	        }

        //! destructor
        ~json_serialization_stack()
	        {
		        // destroy root node; its destructor will destroy everything else
		        delete(this->root);
	        }


        // PUSH METHODS (can be used to implement a 'serialization writer' interface)


        //! Begin a new node at the current level in the tree.
        void push_start_node(const std::string& name, bool empty=false, bool is_insert=false);

        //! Begin a new array at the current level in the tree.
        void push_start_array(const std::string& name, bool empty=false, bool is_insert=false);

        //! End the current element -- node or array.
        //! Raises an exception if there is a mismatch.
        void push_end_element(const std::string& name, bool is_insert=false);

        //! Write attributes to the current node.
        void write_attribute(const std::string& name, const std::string& value, bool is_insert=false);

        //! Write a value.
		    //! If an existing node exists with the same name, its value is replaced.
        void write_value(const std::string& name, const std::string& value, bool is_insert=false);
        void write_value(const std::string& name, unsigned value, bool is_insert=false);
        void write_value(const std::string& name, double value, bool is_insert=false);
        void write_value(const std::string& name, bool value, bool is_insert=false);

		    //! Insert the contents of another json_serialization_stack
		    void merge(json_serialization_stack& other_stack);


        // PULL METHODS (can be used to implement a 'serialization reader' interface)


		    //! Push a bookmark: future pull_reset_head() calls will reset to the current top-of-stack node
		    void push_bookmark();

		    //! Pop a bookmark
		    void pop_bookmark();

        //! Reset the stack to the last bookmark (HEAD if no bookmarks pushed), clear all read flags
        void pull_reset_head();

        //! Reset 'read' counts, either throughout the tree or from the current position.
        typedef enum { current, head } position;
        void pull_reset_unread(position pos);

        //! Begin a new node at the current level in the tree.
        //! The name is *ignored* if the current node is an array;
        //! the next unread element in the array is returned.
        //! Returns true if the node was pulled ok and writes
		    //! the number of elements contained, and the number of
		    //! attributes, in the supplied references
        bool pull_start_node(const std::string& name, unsigned int& elements, unsigned int& attributes);

        //! Begin a new array at the current level in the tree
        //! Returns true if the array was pulled ok.
        bool pull_start_array(const std::string& name, unsigned int& elements);

		    //! Begin a new array element at the current level in the tree.
		    //! Returns true if the pull succeeded.
		    bool pull_array_element(unsigned int& elements);

        //! End the current element -- node or array.
        //! Raises an exception if there is a mismatch.
        void pull_end_element(const std::string& name);

		    //! End the current array element.
		    //! Raises an exception if the top-of-stack item isn't an array.
		    void pull_end_array_element();

        //! Read a named attribute from the current node.
        //! Returns true if the attribute could be read, in which case its
        //! value is stored in the supplied reference
        //! Returns true if the attribute was pulled ok.
        bool read_attribute(const std::string& name, std::string& val);

        //! Read a named value from the current node.
        //! Returns true if the value could be read, in which case it is
        //! stored in the supplied reference
        //! Returns true if the value was pulled ok.
        bool read_value(const std::string& name, std::string& val);
        bool read_value(const std::string& name, unsigned& val);
        bool read_value(const std::string& name, double& val);
        bool read_value(const std::string& name, bool& val);


        // OUTPUT METHODS


        //! Extract contents of this stack as a string
        const std::string get_contents() const;


      protected:

		    //! HEAD node for serialization stack
        root_node* root;

        // note that, below, we have to use std::reference_wrapper, because
        // the STL container classes can't ordinarily take references

				//! Current position within the serialization tree.
		    //! Initialized to the root node (HEAD) by the constructor.
        std::list<basic_node*> node_stack;

		    //! Bookmark stack
		    std::list<basic_node*> bookmarks;
	    };


    void json_serialization_stack::basic_node::push_attribute(element* ele, bool is_insert)
	    {
		    // is_insert not needed (at the moment) for push_attribute

        for(std::list<element*>::iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
	        {
            if((*t)->get_name() == ele->get_name()) t = this->attributes.erase(t);
	        }

        this->attributes.push_back(ele);
	    }


    void json_serialization_stack::basic_node::push_content(element* ele, bool is_insert)
	    {
        for(std::list<element*>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
	        {
            if((*t)->get_name() == ele->get_name()) t = this->contents.erase(t);
	        }

        this->contents.push_back(ele);

		    if(is_insert) this->empty = false;
	    }


    void json_serialization_stack::basic_node::set_unread()
	    {
        // mark this item's read status
        this->read = false;

        // mark status of all attributes and contents
        for(std::list<element*>::iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
	        {
            (*t)->set_unread();
	        }
        for(std::list<element*>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
	        {
            (*t)->set_unread();
	        }
	    }


    bool json_serialization_stack::basic_node::pull_content(element_type pull_type, const std::string& name, element*& ele)
	    {
        bool rval = false;

		    #ifdef __CPP_TRANSPORT_JSON_DEBUG
		    std::cerr << "JSON: node '" << this->get_name() << "' searching contents for '" << name << "', type = " << pull_type << "; ";
		    #endif

        // enquire whether any of our contents will accept a pull request of the specified type
        for(std::list<element*>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
	        {
            if((*t)->pull_enquiry(pull_type, name))
	            {
                ele = *t;
                rval = true;
                break;
	            }
	        }

		    #ifdef __CPP_TRANSPORT_JSON_DEBUG
		    std::cerr << (rval ? "accepted." : "declined.") << std::endl;
		    #endif

        return(rval);
	    }


    bool json_serialization_stack::basic_node::pull_attribute(element_type pull_type, const std::string& name, element*& ele)
	    {
        bool rval = false;

        // enquire whether any of our attributes will accept a pull request of the specified type
        for(std::list<element*>::iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
	        {
            if((*t)->pull_enquiry(pull_type, name))
	            {
                ele = *t;
                rval = true;
                break;
	            }
	        }

        return(rval);
	    }


		void json_serialization_stack::basic_node::merge(json_serialization_stack::basic_node* other_node)
			{
		    // walk through elements from the second node
		    for(std::list<element*>::iterator t = other_node->contents.begin(); t != other_node->contents.end(); t++)
			    {
				    this->push_content(*t, true);
			    }

		    // clear contents of second node, resetting it to an empty state.
				other_node->contents.clear();
			}


    json_serialization_stack::basic_node* json_serialization_stack::user_node::make_element(const std::string& name, bool empty)
	    {
        user_node* n = new user_node(name, empty);
        return(n);
	    }


    bool json_serialization_stack::user_node::validate() const
	    {
        bool rval = true;

        if((this->empty && this->contents.size() > 0) || (!this->empty && this->contents.size() == 0)) rval = false;

        return(rval);
	    }


    std::string json_serialization_stack::user_node::stringize(bool attribute) const
	    {
        std::ostringstream output;

        if(this->empty)
	        {
            output << "'" << this->name << "': {}";
	        }
        else
	        {
            output << "'" << this->name << "': { ";

		        unsigned int count = 0;
            for(std::list<element*>::const_iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
	            {
                if(count > 0) output << ", ";

                output << (*t)->stringize(true);    // mark this element as an attribute
		            count++;
	            }

            for(std::list<element*>::const_iterator t = this->contents.begin(); t != this->contents.end(); t++)
	            {
                if(count > 0) output << ", ";

                output << (*t)->stringize();
		            count++;
	            }

            output << " }";
	        }

        return(output.str());
	    }


    bool json_serialization_stack::user_node::pull_enquiry(json_serialization_stack::element_type pull_type, const std::string& pull_name)
	    {
        bool rval = false;

        // we can service this enquiry if we are unread and it is looking for a node with our name
        if(!this->get_read() && pull_type == node && this->get_name() == pull_name)
	        {
            rval = true;
            this->set_read();
	        }

        return(rval);
	    }


    bool json_serialization_stack::user_node::pull_enquiry(json_serialization_stack::element_type pull_type)
	    {
        bool rval = false;

        // we can service this enquiry if we are unread and it is looking for a node
        if(!this->get_read() && pull_type == node)
	        {
            rval = true;
            this->set_read();
	        }

        return(rval);
	    }


    void json_serialization_stack::user_array::push_content(element* ele, bool is_insert)
	    {
        this->contents.push_back(ele);
		    if(is_insert) this->empty = false;
	    }


    json_serialization_stack::basic_node* json_serialization_stack::user_array::make_element(const std::string& name, bool empty)
	    {
        root_node* n = new root_node(name, empty);
        return(n);
	    }


    bool json_serialization_stack::user_array::validate() const
	    {
        bool rval = true;

        if((this->empty && this->contents.size() > 0) || (!this->empty && this->contents.size() == 0)) rval = false;
        if(this->attributes.size() > 0) rval = false;

        return(rval);
	    }


    std::string json_serialization_stack::user_array::stringize(bool attribute) const
	    {
        std::ostringstream output;

        if(this->empty)
	        {
            output << "'" << this->name << "': []";
	        }
        else
	        {
            output << "'" << this->name << "': [ ";

            // arrays have no attributes, so ignore this field.
            // it should be zero anyway since we were validated when the array was closed.

		        unsigned int count = 0;
            for(std::list<element*>::const_iterator t = this->contents.begin(); t != this->contents.end(); t++)
	            {
                if(count > 0) output << ", ";

                output << (*t)->stringize();
		            count++;
	            }

            output << " ]";
	        }

        return(output.str());
	    }


    bool json_serialization_stack::user_array::pull_enquiry(json_serialization_stack::element_type pull_type, const std::string& pull_name)
	    {
        bool rval = false;

        // we are happy to service this enquiry if we are unread, and if
        // it is looking for an array with our name
        if(!this->get_read() && pull_type == array && this->get_name() == pull_name)
	        {
            rval = true;
            this->set_read();
	        }

        return(rval);
	    }


    bool json_serialization_stack::user_array::pull_enquiry(json_serialization_stack::element_type pull_type)
	    {
        bool rval = false;

        // we are happy to service this enquiry if we are unread, and if it is looking for an array
        if(!this->get_read() && pull_type == array)
	        {
            rval = true;
            this->set_read();
	        }

        return(rval);
	    }


		bool json_serialization_stack::user_array::pull_element(element*& ele)
			{
				bool rval = false;

				#ifdef __CPP_TRANSPORT_JSON_DEBUG
				std::cerr << "JSON: array '" << this->get_name() << "' searching for an available element; ";
				#endif

				// enquire whether any of our contents are available
				for(std::list<element*>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
					{
						if((*t)->pull_enquiry(node))
							{
								ele = *t;
								rval = true;
								break;
							}
					}

				#ifdef __CPP_TRANSPORT_JSON_DEBUG
				std::cerr << (rval ? "accepted." : "declined.") << std::endl;
				#endif

				return(rval);
			}

    json_serialization_stack::basic_node* json_serialization_stack::root_node::make_element(const std::string& name, bool empty)
	    {
        user_node* n = new user_node(name, empty);
        return(n);
	    }


    bool json_serialization_stack::root_node::validate() const
	    {
        bool rval = true;

        if((this->empty && this->contents.size() > 0) || (!this->empty && this->contents.size() == 0)) rval = false;

        return(rval);
	    }


    std::string json_serialization_stack::root_node::stringize(bool attribute) const
	    {
        std::string r = "{ ";

		    unsigned int count = 0;
        for(std::list<element*>::const_iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
	        {
            if(count > 0) r += std::string(", ");

            r += (*t)->stringize(true);
		        count++;
	        }

        for(std::list<element*>::const_iterator t = this->contents.begin(); t != this->contents.end(); t++)
	        {
            if(count > 0) r += std::string(", ");

            r += (*t)->stringize();
		        count++;
	        }

        r += " }";

        return(r);
	    }


    bool json_serialization_stack::root_node::pull_enquiry(json_serialization_stack::element_type pull_type, const std::string& pull_name)
	    {
        bool rval = false;

        // we are happy to service a pull request if we are unread, and it is looking for a node with our name
        if(!this->get_read() && pull_type == node && this->get_name() == pull_name)
	        {
            rval = true;
            this->set_read();
	        }

        return(rval);
	    }


    bool json_serialization_stack::root_node::pull_enquiry(json_serialization_stack::element_type pull_type)
	    {
        bool rval = false;

        // we are happy to service a pull request if we are unread, and it is looking for a node
        if(!this->get_read() && pull_type == node)
	        {
            rval = true;
            this->set_read();
	        }

        return(rval);
	    }


		template <typename T>
    std::string json_serialization_stack::value_element<T>::stringize(bool attribute) const
	    {
		    std::ostringstream output;

				output << "'" << (attribute ? std::string(__CPP_TRANSPORT_JSON_ATTRIBUTE_TAG) : std::string(""))
											<< this->name
							 << "': "
							 << this->to_string(this->value);

				return(output.str());
	    }


		template <typename T>
		std::string json_serialization_stack::value_element<T>::to_string(const std::string& v) const
			{
				return(std::string("'") + v + std::string("'"));
			}


		template <typename T>
		std::string json_serialization_stack::value_element<T>::to_string(const unsigned int& v) const
			{
				return(boost::lexical_cast<std::string>(v));
			}


    template <typename T>
    std::string json_serialization_stack::value_element<T>::to_string(const double& v) const
	    {
        return(boost::lexical_cast<std::string>(v));
	    }


    template <typename T>
    std::string json_serialization_stack::value_element<T>::to_string(const bool& v) const
	    {
        return(boost::lexical_cast<std::string>(v));
	    }


		template <typename T>
    bool json_serialization_stack::value_element<T>::pull_enquiry(json_serialization_stack::element_type pull_type, const std::string& pull_name)
	    {
        bool rval = false;

        // we are happy to service a pull request if we are unread, and it is looking for a value with our name
        if(!this->get_read() && (pull_type == element_type::value) && (this->get_name() == pull_name))
	        {
            rval = true;
            this->set_read();
	        }

        return(rval);
	    }


		template <typename T>
    bool json_serialization_stack::value_element<T>::pull_enquiry(json_serialization_stack::element_type pull_type)
	    {
        bool rval = false;

        // we are happy to service a pull request if we are unread, and it is looking for a value
        if(!this->get_read() && pull_type == element_type::value)
	        {
            rval = true;
            this->set_read();
	        }

        return(rval);
	    }


    // push: create a new node at the current level
    void json_serialization_stack::push_start_node(const std::string& name, bool empty, bool is_insert)
	    {
        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTY << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and push the new node to its contents
        // then, make the new node the current front-of-stack one
        json_serialization_stack::basic_node* n = this->node_stack.front();

        // get front-of-stack node to synthesize a new element.
        // if it is a user_node, this will be another user_node.
        // if it is an array, it will be a root_node.
        json_serialization_stack::basic_node* node = n->make_element(name, empty);

        n->push_content(node, is_insert);
        this->node_stack.push_front(node);

		    #ifdef __CPP_TRANSPORT_JSON_DEBUG
        std::cerr << "JSON: start writing node '" << name << "'" << std::endl;
		    #endif
	    }


    // pull: read a new node at the current level
    bool json_serialization_stack::pull_start_node(const std::string& name, unsigned int& elements, unsigned int& attributes)
	    {
        bool rval = false;

		    if(this->node_stack.size() == 0)
			    {
		        std::ostringstream msg;
				    msg << __CPP_TRANSPORT_SERIAL_PULLEMPTY << name << "'";
				    throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
			    }

		    // get reference to front-of-stack node, and check whether it can service this request
		    // note, if the top-of-stack item is an array then it will ignore names when we
		    // make the enquiry
        basic_node* n = this->node_stack.front();

		    element* ele;

		    // if successful, push the node we have just pulled to the top of the stack
		    if((rval = n->pull_content(node, name, ele)))
			    {
				    // cast element up to basic_node; will throw an exception if this isn't possible
				    basic_node* node = dynamic_cast<basic_node*>(ele);

				    elements = node->get_num_contents();
				    attributes = node->get_num_attributes();

				    this->node_stack.push_front(node);

				    #ifdef __CPP_TRANSPORT_JSON_DEBUG
				    std::cerr << "JSON: start reading node '" << node->get_name() << "'" << std::endl;
				    #endif
			    }
		    else
			    {
		        #ifdef __CPP_TRANSPORT_JSON_DEBUG
		        std::cerr << "JSON: failed to start reading node '" << name << "'" << std::endl;
				    #endif
			    }

        return(rval);
	    }


    // push: create a new array
    void json_serialization_stack::push_start_array(const std::string& name, bool empty, bool is_insert)
	    {

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTY << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and push the new node to its contents
        // then, make the new node the current front-of-stack one
        basic_node* n = this->node_stack.front();

        // make a new array element; both arrays and nodes can have these as members, so
        // no need to distinguish here
        user_array* array = new user_array(name, empty);

        n->push_content(array, is_insert);
        this->node_stack.push_front(array);

		    #ifdef __CPP_TRANSPORT_JSON_DEBUG
        std::cerr << "JSON: Start writing array '" << name << "'" << std::endl;
		    #endif
	    }


    // pull: read a new array at the current level
    bool json_serialization_stack::pull_start_array(const std::string& name, unsigned int& elements)
	    {
        bool rval = false;

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PULLEMPTY << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and check whether it can service this request
        basic_node* n = this->node_stack.front();

		    element* ele = nullptr;

        // if successful, push the node we have just pulled to the top of the stack
        if((rval = n->pull_content(array, name, ele)))
	        {
            // cast element up to basic_node
		        basic_node* node = dynamic_cast<basic_node*>(ele);

		        elements = node->get_num_contents();

            this->node_stack.push_front(node);

		        #ifdef __CPP_TRANSPORT_JSON_DEBUG
            std::cerr << "JSON: start reading array '" << node->get_name() << "'" << std::endl;
		        #endif
	        }
        else
	        {
		        #ifdef __CPP_TRANSPORT_JSON_DEBUG
            std::cerr << "JSON: failed to start reading array '" << name << "'" << std::endl;
		        #endif
	        }

        return(rval);
	    }


		// pull: read a new array element at the current level
		bool json_serialization_stack::pull_array_element(unsigned int& elements)
			{
				bool rval = false;

		    if(this->node_stack.size() == 0)
			    throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_SERIAL_PULLEMPTYARRAY);

		    // get reference to front-of-stack node, and check whether it is (1) an array, and (2) can service this request
		    basic_node* n = this->node_stack.front();

 				user_array* a = dynamic_cast<user_array*>(n);

				if(a != nullptr)
					{
						element* ele = nullptr;

						if((rval = a->pull_element(ele)))
							{
								basic_node* node = dynamic_cast<basic_node*>(ele);

								elements = node->get_num_contents();

								this->node_stack.push_front(node);

								#ifdef __CPP_TRANSPORT_JSON_DEBUG
								std::cerr << "JSON: start reading array element '" << node->get_name() << "'" << std::endl;
								#endif
							}
						else
							{
								#ifdef __CPP_TRANSPORT_JSON_DEBUG
						    std::cerr << "JSON: failed to start reading array element" << std::endl;
								#endif
							}
					}
				else throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_SERIAL_NO_TOP_ARRAY);

				return(rval);
			}


    // push: end the current node
    void json_serialization_stack::push_end_element(const std::string& name, bool is_insert)
	    {
        // can't end the node if it is the root one
        if(this->node_stack.size() == 1)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_ENDNODE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get current front-of-stack node, and check that its name matches the
        // one we have been given; if not raise an error
        basic_node* n = this->node_stack.front();
        if(n->get_name() != name)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_ENDNAME_A << n->get_name() << __CPP_TRANSPORT_SERIAL_ENDNAME_B << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // validate this element
        if(!is_insert && !n->validate())
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_VALIDATE_FAIL << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // pop current front-of-stack node, reverting to whatever was on the stack previously
        this->node_stack.pop_front();

		    #ifdef __CPP_TRANSPORT_JSON_DEBUG
        std::cerr << "JSON: Finished writing element '" << name << "'" << std::endl;
		    #endif
	    }


		// pull: end the current node
		void json_serialization_stack::pull_end_element(const std::string& name)
			{
				// can't end the node if it is the root one
				if(this->node_stack.size() == 1)
					{
				    std::ostringstream msg;
						msg << __CPP_TRANSPORT_SERIAL_ENDNODE << name << "'";
						throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
					}

				// get current front-of-stack node, and check that its name matches the
				// one we have been given; if not, raise an error
		    basic_node* n = this->node_stack.front();
				if(n->get_name() != name)
					{
				    std::ostringstream msg;
						msg << __CPP_TRANSPORT_SERIAL_ENDNAME_A << n->get_name() << __CPP_TRANSPORT_SERIAL_ENDNAME_B << name << "'";
						throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
					}

				#ifdef __CPP_TRANSPORT_JSON_DEBUG
		    std::cerr << "JSON: finished reading element '" << n->get_name() << "'" << std::endl;
				#endif

				// pop current front-of-stack node, reverting to whatever was on the stack previously
				this->node_stack.pop_front();
			}


		// pull: end current array element
		void json_serialization_stack::pull_end_array_element()
			{
		    // can't end the node if it is the root one
		    if(this->node_stack.size() == 1)
			    {
		        std::ostringstream msg;
		        msg << __CPP_TRANSPORT_SERIAL_END_ARRAY_ELEMENT;
		        throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
			    }

		    // pop current front-of-stack node, reverting to whatever was on the stack previously
		    this->node_stack.pop_front();

				// check that the new front-of-stack node is an array
		    basic_node* n = this->node_stack.front();

		    user_array* a = dynamic_cast<user_array*>(n);
		    if(a == nullptr) throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_TOP_OF_STACK_NOT_ARRAY);

				#ifdef __CPP_TRANSPORT_JSON_DEBUG
		    std::cerr << "JSON: finished reading array element" << std::endl;
				#endif
			}


    // push: write attributes to the current node
    void json_serialization_stack::write_attribute(const std::string& name, const std::string& value, bool is_insert)
	    {
        value_element<std::string>* ele = new value_element<std::string>(name, value);

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTYATTR << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this attribute to it
        basic_node* n = this->node_stack.front();
        n->push_attribute(ele, is_insert);

		    #ifdef __CPP_TRANSPORT_JSON_DEBUG
        std::cerr << "JSON: Wrote attribute '" << name << "' = '" << value << "'" << std::endl;
		    #endif
	    }


		// pull: read attributes from the current node
		bool json_serialization_stack::read_attribute(const std::string& name, std::string& val)
			{
		    bool rval = false;

		    if(this->node_stack.size() == 0)
			    {
		        std::ostringstream msg;
		        msg << __CPP_TRANSPORT_SERIAL_PULLEMPTYATTR << name << "'";
		        throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
			    }

		    // get reference to front-of-stack node, and check whether it can service this request
				basic_node* n = this->node_stack.front();
				element* ele = nullptr;

		    if((rval = n->pull_attribute(value, name, ele)))
			    {
		        // if successful, extract
				    basic_value_element* value = dynamic_cast< basic_value_element* >(ele);
				    if(value == nullptr) throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_SERIAL_TYPEDETECT_FAIL);
				    val = value->get_string();

				    #ifdef __CPP_TRANSPORT_JSON_DEBUG
		        std::cerr << "JSON: Read attribute '" << name << "' = '" << val << "'" << std::endl;
				    #endif
			    }

				return(rval);
			}


    // Push: Write values to the current node
    //   There are specializations of this function for strings, unsigned integers, doubles and booleans


    void json_serialization_stack::write_value(const std::string& name, const std::string& value, bool is_insert)
	    {
        value_element<std::string>* ele = new value_element<std::string>(name, value);

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node
        basic_node* n = this->node_stack.front();
        n->push_content(ele, is_insert);

		    #ifdef __CPP_TRANSPORT_JSON_DEBUG
        std::cerr << "JSON: Wrote string value '" << name << "' = '" << value << "'" << std::endl;
		    #endif
	    }


    void json_serialization_stack::write_value(const std::string& name, unsigned value, bool is_insert)
	    {
        value_element<unsigned int>* ele = new value_element<unsigned int>(name, value);

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this value to its contents
        basic_node* n = this->node_stack.front();
        n->push_content(ele, is_insert);

		    #ifdef __CPP_TRANSPORT_JSON_DEBUG
        std::cerr << "JSON: Wrote unsigned int value '" << name << "' = " << value << std::endl;
		    #endif
	    }


    void json_serialization_stack::write_value(const std::string& name, double value, bool is_insert)
	    {
        value_element<double>* ele = new value_element<double>(name, value);

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this value to its contents
        basic_node* n = this->node_stack.front();
        n->push_content(ele, is_insert);

		    #ifdef __CPP_TRANSPORT_JSON_DEBUG
        std::cerr << "JSON: Wrote double value '" << name << "' = " << value << std::endl;
		    #endif
	    }


    void json_serialization_stack::write_value(const std::string& name, bool value, bool is_insert)
	    {
        value_element<bool>* ele = new value_element<bool>(name, value);

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this value to its contents
        basic_node* n = this->node_stack.front();
        n->push_content(ele, is_insert);

		    #ifdef __CPP_TRANSPORT_JSON_DEBUG
        std::cerr << "JSON: Wrote boolean value '" << name << "' = " << value << std::endl;
		    #endif
	    }


		void json_serialization_stack::merge(json_serialization_stack& other_stack)
			{
		    if(this->node_stack.size() == 0)
			    throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_SERIAL_PUSHEMTPY_MERGE);

		    // get reference to current front-of-stack node, and push this value to its contents
		    basic_node* n = this->node_stack.front();

		    // merge root node of second stack with our own top-of-stack element.
		    // This empties the contents of the second stack.
				// The element* handles orphaned in this way are now part of our own stack,
				// and will be deallocated when that is destroyed.
		    n->merge(other_stack.root);
			}


		// Pull: Read values from the current node
    //   There are specializations of this function for strings, unsigned integers, doubles and booleans


    bool json_serialization_stack::read_value(const std::string& name, std::string& val)
	    {
        bool rval = false;

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PULLEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and check whether it can service this request
        basic_node* n = this->node_stack.front();
		    element* ele = nullptr;

        if((rval = n->pull_content(value, name, ele)))
	        {
            // if successful, extract
		        basic_value_element* value = dynamic_cast< basic_value_element* >(ele);
            if(value == nullptr) throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_SERIAL_TYPEDETECT_FAIL);
            val = value->get_string();

		        #ifdef __CPP_TRANSPORT_JSON_DEBUG
		        std::cerr << "JSON: read string value '" << name << "' = '" << val << "'" << std::endl;
		        #endif
	        }

        return(rval);
	    }


    bool json_serialization_stack::read_value(const std::string& name, unsigned int& val)
	    {
        bool rval = false;

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PULLEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and check whether it can service this request
        basic_node* n = this->node_stack.front();
		    element* ele = nullptr;

        if((rval = n->pull_content(value, name, ele)))
	        {
            // if successful, extract
		        basic_value_element* value = dynamic_cast< basic_value_element* >(ele);
            if(value == nullptr) throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_SERIAL_TYPEDETECT_FAIL);
            val = value->get_unsigned_int();

		        #ifdef __CPP_TRANSPORT_JSON_DEBUG
            std::cerr << "JSON: read unsigned int value '" << name << "' = " << val << std::endl;
		        #endif
	        }

        return(rval);
	    }


    bool json_serialization_stack::read_value(const std::string& name, double& val)
	    {
        bool rval = false;

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PULLEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and check whether it can service this request
        basic_node* n = this->node_stack.front();
		    element* ele = nullptr;

        if((rval = n->pull_content(value, name, ele)))
	        {
            // if successful, extract
		        basic_value_element* value = dynamic_cast<basic_value_element*>(ele);
            if(value == nullptr) throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_SERIAL_TYPEDETECT_FAIL);
            val = value->get_double();

		        #ifdef __CPP_TRANSPORT_JSON_DEBUG
            std::cerr << "JSON: read double value '" << name << "' = " << val << std::endl;
		        #endif
	        }

        return(rval);
	    }


    bool json_serialization_stack::read_value(const std::string& name, bool& val)
	    {
        bool rval = false;

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PULLEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and check whether it can service this request
        basic_node* n = this->node_stack.front();
		    element* ele = nullptr;

        if((rval = n->pull_content(value, name, ele)))
	        {
            // if successful, extract
		        basic_value_element* value = dynamic_cast< basic_value_element* >(ele);
            if(value == nullptr) throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_SERIAL_TYPEDETECT_FAIL);
            val = value->get_bool();

		        #ifdef __CPP_TRANSPORT_JSON_DEBUG
            std::cerr << "JSON: read bool value '" << name << "' = " << val << std::endl;
		        #endif
	        }

        return(rval);
	    }


		// Push current stack position to bookmarks
		void json_serialization_stack::push_bookmark()
			{
				this->bookmarks.push_front(this->node_stack.front());
			}


		// Pop bookmark from the stack
		void json_serialization_stack::pop_bookmark()
			{
				if(this->bookmarks.size() <= 1)
					throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_SERIAL_BOOKMARKS_POPLAST);

				this->bookmarks.pop_front();
			}


    // Reset top-of-stack from the last bookmark, and mark all items as unread
    void json_serialization_stack::pull_reset_head()
	    {
		    if(this->bookmarks.size() == 0)
			    throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_SERIAL_BOOKMARKS_EMPTY);

		    #ifdef __CPP_TRANSPORT_JSON_DEBUG
        std::cerr << std::endl << "JSON: RESETTING STACK TO TOP BOOKMARK" << std::endl << std::endl;
		    #endif

        // empty stack, and push the last bookmark back to it
        this->node_stack.clear();

        basic_node* bk_mk = this->bookmarks.front();
        this->node_stack.push_front(bk_mk);

        // mark all items unread, recursively, from the bookmark
		    bk_mk->set_unread();
	    }


    // Reset read status, leaving the stack intact.
    // Works either from the current position on the stack or the root of the tree
    void json_serialization_stack::pull_reset_unread(json_serialization_stack::position pos)
	    {
        if(this->bookmarks.size() == 0)
	        throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, __CPP_TRANSPORT_SERIAL_BOOKMARKS_EMPTY);

        switch(pos)
	        {
            case json_serialization_stack::head:
	            {
                basic_node* bk_mk = this->bookmarks.front();
                bk_mk->set_unread();

								#ifdef __CPP_TRANSPORT_JSON_DEBUG
                std::cerr << std::endl << "JSON: RESETTING READ COUNT FROM LAST BOOKMARK" << std::endl << std::endl;
								#endif

                break;
	            }

            case json_serialization_stack::current:
	            {
                basic_node* n = this->node_stack.front();
                n->set_unread();

								#ifdef __CPP_TRANSPORT_JSON_DEBUG
                std::cerr << std::endl << "JSON: RESETTING READ COUNT FROM TOP-OF-STACK" << std::endl << std::endl;
								#endif

                break;
	            }

            default:
	            assert(false);
	        }
	    }


    // Extract stringized contents of this serialization_writer
    const std::string json_serialization_stack::get_contents() const
	    {
        std::string output;

        // ensure top-of-stack object is the root node
        if(this->node_stack.size() != 1)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_NOT_FINISHED;
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        output = this->root->stringize();

        return(output);
	    }

	}   // namespace transport


#endif //__json_serialization_stack_H_
