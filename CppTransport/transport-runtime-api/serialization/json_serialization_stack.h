//
// Created by David Seery on 07/05/2014.
// Copyright (c) 2014 University of Sussex. All rights reserved.
//


#ifndef __json_serialization_stack_H_
#define __json_serialization_stack_H_


#include <string>
#include <list>
#include <functional>
#include <utility>

#include "transport-runtime-api/exceptions.h"
#include "transport-runtime-api/messages.h"

#include "boost/lexical_cast.hpp"


#define __CPP_TRANSPORT_SERIALIZABLE_ROOT_NODE "root"


namespace transport
	{

    //! implements an serialization stack, which can be the basis of
    //! either a serialization_writer or serialization_reader interface.

    class json_serialization_stack
	    {
      protected:

        // set up an abstract class hierarchy representing the
        // elements of which the serialization is composed.
        // 'element' is the basic abstract type
        //   'nodes' are elements which may have attributes and contents. It is an abstract type
        //     'user_node' is the typical node generated by a class performing serialization.
        //     'root_node' is a special node type representing the base of a serialization tree.
        //       they can be the base for the entire serialization, or the elements in an array
        //       root nodes stringize slightly differently, but are otherwise the same as user_nodes
        //   'value_element' is a container for some value type

        //! When pulling from the stack, need a tag to describe what type of
        //! data is expected. Elements can accept or decline a pull based on the
        //! type of data being asked for
        typedef enum { value, node, array } element_type;

        //! element: most general object which can be in the serialization tree
        class element
	        {
          public:
            //! Constructor, specified name
            void element(const std::string& nm)
	            : name(nm), read(false)
	            {
	            }

            //! Create a virtual destructor to ensure destructors for derived classes get called
            virtual ~element()
	            {
	            }

            //! Get name
            const std::string& get_name() { return(this->name); }

            //! Mark this item as unread.
            //! May be overridden by derived classes which contain extra data,
            //! eg. nodes or arrays
            virtual void set_unread() { this->read = false; }

            //! Enquire whether this element will accept a pull request with a specified field name
            //! This should be implemented by a derived class.
            virtual bool pull_enquiry(element_type pull_type, const std::string& pull_name) = 0;

		        //! Enquire whether this element will accept a pull request, with no name specified
		        //! This should be implemented by the derived class.
		        //! It is used by arrays to pick out elements, since in arrays there is no concept of a name.
		        virtual bool pull_enquiry(element_type pull_type) = 0;

            //! 'attribute' marks that this element is an attribute
            //! it's up to the attribute element whether it uses this information
            //! at present, it is used to map XML-style attributes
            //! to a '@' tag for JSON fields
            virtual std::string stringize(bool attribute=false) const = 0;

            //! Self-validate -- used when ending a node
            virtual bool validate() const = 0;

          protected:

		        //! Get read status of this element
		        bool get_read() { return(this->read); }

		        //! Mark this element as read
		        void set_read() { this->read = true; }

          protected:

            //! Name of this element
            std::string name;

            //! Has this element been read? Used when pulling items off the stack
            bool read;
	        };


        //! basic_node: most general container type in the serialization tree.
        //! specializations are named or unnamed nodes, or arrays
        class basic_node: public element
	        {
          public:

            //! Constructor with specified name and empty state.
            void basic_node(const std::string& nm, bool emp=false)
	            : empty(emp), element(nm)
	            {
	            }

            //! Declare virtual destructor so destructors of derived classes get called
            virtual ~basic_node()
	            {
	            }

            //! Mark this item as unread. Over-rides implementation in 'element', because
            //! we recursively set the read-state of our attributes and contents.
            virtual void set_unread() override;

            //! Derived classes should implement a method to make a new contents element,
            //! suitable for storage within this node. What this should be can vary depending whether the node is an array,
            //! a user_node or a root_node
            virtual basic_node make_element(const std::string& name, bool empty=false) const = 0;

            //! Push an element to our contents.
            void push_content(element& ele) { this->contents.push_back(ele); }

            //! Push an element to our attributes.
            void push_attribute(element& ele) { this->attributes.push_back(ele); }

            //! Enquire whether this node can service a request to pull some particular content.
		        //! Returns false if it cannot.
            //! Otherwise, returns true and writes the pulled element into the supplied reference.
            bool pull_content(element_type pull_type, const std::string& name, std::reference_wrapper<element>& ele);

            //! Enquire whether this node can service a request to pull a particular named attribute.
		        //! Returns false if it cannot.
            //! Otherwise, returns true and writes the pulled element into the supplied reference.
            bool pull_attribute(element_type pull_type, const std::string& name, std::reference_wrapper<element>& ele);

          protected:

            //! true = this node is empty, or should be empty. Used during validation.
            bool empty;

            //! list of elements representing attributes
            std::list<element> attributes;

            //! list of elements representing the contents of this node
            std::list<element> contents;
	        };


        void basic_node::set_unread()
	        {
            // mark this item's read status
            this->read = false;

            // mark status of all attributes and contents
            for(std::list<element>::iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
	            {
                (*t).set_unread();
	            }
            for(std::list<element>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
	            {
                (*t).set_unread();
	            }
	        }


        bool basic_node::pull_content(element_type pull_type, const std::string& name, std::reference_wrapper<element>& ele)
	        {
		        bool rval = false;

		        // enquire whether any of our contents will accept a pull request of the specified type
		        for(std::list<element>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
			        {
				        if((*t).pull_enquiry(pull_type, name))
					        {
						        ele = std::ref<element>(*t);
						        rval = true;
						        break;
					        }
			        }

            return(rval);
	        }


		    bool basic_node::pull_attribute(element_type pull_type, const std::string& name, std::reference_wrapper<element>& ele)
			    {
				    bool rval = false;

				    // enquire whether any of our attributes will accept a pull request of the specified type
				    for(std::list<element>::iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
					    {
						    if((*t).pull_enquiry(pull_type, name))
							    {
								    ele = std::ref<element>(*t);
								    rval = true;
								    break;
							    }
					    }

				    return(rval);
			    }


        class user_node: public basic_node
	        {
          public:

            //! Constructor with specified name and empty state
            void user_node(const std::string& nm, bool emp=false)
	            : basic_node(nm, emp)
	            {
	            }

            //! Stringize this user_node for serialization to JSON
            virtual std::string stringize(bool attribute=false) const override;

            //! Self-validate. Here, we need only check that if empty, we have no contents
            virtual bool validate() const override;

            //! Override base_node function to make a new contents element suitable for storage in this node.
            //! For a user_array, this should be a root_node
            virtual basic_node make_element(const std::string& name, bool empty=false) const override;

		        //! Override element function to service a named pull enquiry
            virtual bool pull_enquiry(element_type pull_type, const std::string& pull_name) override;

		        //! Override element function to service a nameless pull enquiry
		        virtual bool pull_enquiry(element_type pull_type) override;

	        };


        basic_node virtual user_node::make_element(const std::string& name, bool empty=false) const
	        {
            user_node n(name, empty);
            return(n);
	        }


        bool virtual user_node::validate() const
	        {
            bool rval = true;

            if(this->empty && this->contents.size() > 0 || !this->empty && this->contents.size() == 0) rval = false;

            return(rval);
	        }


        std::string virtual user_node::stringize(bool attribute=false) const
	        {
            std::string r;

            if(this->empty)
	            {
                r = this->name + ": ";
	            }
            else
	            {
                r = this->name + ": { ";

                for(std::list<element>::iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
	                {
                    if(t != this->attributes.begin())
	                    {
                        r += std::string(", ");

                        r += (*t).stringize(true);    // mark this element as an attribute
	                    }
	                }

                for(std::list<element>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
	                {
                    if(t != this->contents.begin())
	                    {
                        r += std::string(", ");

                        r += (*t).stringize();
	                    }
	                }

                r += " }";
	            }

            return(r);
	        }


        bool virtual  user_node::pull_enquiry(element_type pull_type, const std::string& pull_name)
	        {
		        bool rval = false;

		        // we can service this enquiry if we are unread and it is looking for a node with our name
		        if(!this->get_read() && pull_type == node && this->get_name() == pull_name)
			        {
		            rval = true;
				        this->set_read();
			        }

						return(rval);
	        }


        bool virtual user_node::pull_enquiry(element_type pull_type)
	        {
            bool rval = false;

            // we can service this enquiry if we are unread and it is looking for a node
            if(!this->get_read() && pull_type == node)
	            {
                rval = true;
                this->set_read();
	            }

            return(rval);
	        }


        class user_array: public basic_node
	        {
          public:

            //! Constructor with specified name and empty state
            void user_array(const std::string& nm, bool emp=false)
	            : basic_node(nm, emp)
	            {
	            }

            //! Stringize this user_array for serialization to JSON
            virtual std::string stringize(bool attribute=false) const override;

		        //! Self-validate. Here, we should check that if we are supposed to be empty we have no content.
            virtual bool validate() const override;

            //! Override basic_node function to make a new contents element suitable for storage in this node.
            //! For a user_array, this should be a root_node
            virtual basic_node make_element(const std::string& name, bool empty=false) const override;

		        //! Override element function to service a named pull enquiry
            virtual bool pull_enquiry(element_type pull_type, const std::string& pull_name) override;

		        //! Override element function to service a nameless pull enquiry
		        virtual bool pull_enquiry(element_type pull_type) override;
	        };


        basic_node virtual user_array::make_element(const std::string& name, bool empty=false) const
	        {
            root_node n(name, empty);
            return(n);
	        }


        bool virtual user_array::validate() const
	        {
            bool rval = true;

            if(this->empty && this->contents.size() > 0 || !this->empty && this->contents.size() == 0) rval = false;
            if(this->attributes.size() > 0) rval = false;

            return(rval);
	        }


        std::string virtual user_array::stringize(bool attribute=false) const
	        {
            std::string r;

            if(this->empty)
	            {
                r = this->name + ": []";
	            }
            else
	            {
                r = this->name + ": [ ";

                // arrays have no attributes, so ignore this field.
                // it should be zero anyway since we were validated when the array was closed.

                for(std::list<element>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
	                {
                    if(t != this->contents.begin())
	                    {
                        r += std::string(", ");

                        r += (*t).stringize();
	                    }
	                }

                r += " ]";
	            }

            return(r);
	        }


        bool virtual user_array::pull_enquiry(element_type pull_type, const std::string& pull_name)
	        {
            bool rval = false;

		        // we are happy to service this enquiry if we are unread, and if
		        // it is looking for an array with our name
		        if(!this->get_read() && pull_type == array && this->get_name() == pull_name)
			        {
		            rval = true;
				        this->set_read();
			        }

		        return(rval);
	        }


        bool virtual user_array::pull_enquiry(element_type pull_type)
	        {
            bool rval = false;

            // we are happy to service this enquiry if we are unread, and if it is looking for an array
            if(!this->get_read() && pull_type == array)
	            {
                rval = true;
                this->set_read();
	            }

            return(rval);
	        }


        class root_node: public basic_node
	        {
          public:

            //! Constructor with specified name and empty state
            void root_node(const std::string& nm, bool emp=false)
	            : basic_node(nm, emp)
	            {
	            }

            //! Stringize this root_node for serialization to JSON.
            //! root_node stringizes like user_node, except that we don't generate a field name and a value,
            //! only a group of JSON fields surrounded by { ... }
            virtual std::string stringize(bool attribute=false) const override;

            //! Self-validate. Here, as for a user_node, we need only check that if empty, we have no contents
            virtual bool validate() const override;

            //! Make a new contents element. For us, this should be a user-node
            virtual basic_node make_element(const std::string& name, bool empty=false) const override;

            //! Override element function to service a named pull enquiry
            virtual bool pull_enquiry(element_type pull_type, const std::string& pull_name) override;

		        //! Override element function to service a nameless pull enquiry
		        virtual bool pull_enquiry(element_type pull_type) override;
	        };


        basic_node virtual root_node::make_element(const std::string& name, bool empty=false) const
	        {
            user_node n(name, empty);
            return(n);
	        }


        bool virtual root_node::validate() const
	        {
            bool rval = true;

            if(this->empty && this->contents.size() > 0 || !this->empty && this->contents.size() == 0) rval = false;

            return(rval);
	        }


        std::string virtual root_node::stringize(bool attribute=false) const
	        {
            std::string r = "{ ";

            for(std::list<element>::iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
	            {
                if(t != this->attributes.begin())
	                {
                    r += std::string(", ");

                    r += (*t).stringize();
	                }
	            }

            for(std::list<element>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
	            {
                if(t != this->contents.begin())
	                {
                    r += std::string(", ");

                    r += (*t).stringize();
	                }
	            }

            r += " }";

            return(r);
	        }


        bool virtual root_node::pull_enquiry(element_type pull_type, const std::string& pull_name)
	        {
		        bool rval = false;

		        // we are happy to service a pull request if we are unread, and it is looking for a node with our name
            if(!this->get_read() && pull_type == node && this->get_name() == pull_name)
	            {
                rval = true;
                this->set_read();
	            }

            return(rval);
	        }


        bool virtual root_node::pull_enquiry(element_type pull_type)
	        {
            bool rval = false;

            // we are happy to service a pull request if we are unread, and it is looking for a node
            if(!this->get_read() && pull_type == node)
	            {
                rval = true;
                this->set_read();
	            }

            return(rval);
	        }


        template <typename T>
        class value_element: public element
	        {
          public:

            //! Constructor with specified name and stored value
            void value_element(const std::string& nm, const T& val)
	            : value(val), element(nm)
	            {
	            }

            //! Get value
            const T& get_value() { return(this->value); }

            //! Stringize the value stored in this element for serialization to JSON.
            virtual std::string stringize(bool attribute=false) const override;

            //! Self-validate. For value_element there is nothing to do.
            virtual bool validate() const override { return(true); }

            //! Override element function to service a named pull enquiry
            virtual bool pull_enquiry(element_type pull_type, const std::string& pull_name) override;

		        //! OVerride element function to service a nameless pull enquiry
		        virtual bool pull_enquiry(element_type pull_type) override;

		        //! Convert content to different representations, if possible
		        std::string  get_string()       { return(boost::lexical_cast<std::string>(this->value)); }
            unsigned int get_unsigned_int() { return(boost::lexical_cast<unsigned int>(this->value)); }
            double       get_double()       { return(boost::lexical_cast<double>(this->value)); }
            bool         get_bool()         { return(boost::lexical_cast<bool>(this->value)); }

          protected:
            //! Stored value
            T value;
	        };


        std::string virtual value_element::stringize(bool attribute=false) const
	        {
            std::string v = boost::lexical_cast<std::string>(this->value);

            return((attribute ? std::string("@") : std::string("")) + this->name + ": " + this->value);
	        }


        bool virtual value_element::pull_enquiry(element_type pull_type, const std::string& pull_name)
	        {
            bool rval = false;

            // we are happy to service a pull request if we are unread, and it is looking for a value with our name
            if(!this->get_read() && pull_type == value && this->get_name() == pull_name)
	            {
                rval = true;
                this->set_read();
	            }

            return(rval);
	        }


        bool virtual value_element::pull_enquiry(element_type pull_type)
	        {
            bool rval = false;

            // we are happy to service a pull request if we are unread, and it is looking for a value
            if(!this->get_read() && pull_type == value)
	            {
                rval = true;
                this->set_read();
	            }

            return(rval);
	        }


      public:

        //! create an json_serialization_stack

        void json_serialization_stack()
	        : root(__CPP_TRANSPORT_SERIALIZABLE_ROOT_NODE, false)
	        {
            // push the root node onto the current stack
            this->push_stack.push_front(std::ref(static_cast<basic_node>(this->root)));
            this->push_stack.push_front(std::ref(static_cast<basic_node>(this->root)));
	        }

        //! destructor
        ~json_serialization_stack()
	        {
	        }


        // PUSH METHODS (can be used to implement a 'serialization writer' interface)


        //! Begin a new node at the current level in the tree.
        void push_start_node(const std::string& name, bool empty=false);

        //! Begin a new array at the current level in the tree.
        void push_start_array(const std::string& name, bool empty=false);

        //! End the current element -- node or array.
        //! Raises an exception if there is a mismatch.
        void push_end_element(const std::string& name);

        //! Write attributes to the current node.
        void write_attribute(const std::string& name, const std::string& value);

        //! Write a value.
        void write_value(const std::string& name, const std::string& value);
        void write_value(const std::string& name, unsigned value);
        void write_value(const std::string& name, double value);
        void write_value(const std::string& name, bool value);


        // PULL METHODS (can be used to implement a 'serialization reader' interface)


        //! Reset the pull stack to HEAD.
        void pull_reset_head();

        //! Reset 'read' counts, either throughout the tree or from the current position.
        typedef enum { current, head } position;
        void pull_reset_unread(position pos);

        //! Begin a new node at the current level in the tree.
        //! The name is *ignored* if the current node is an array;
        //! the next unread element in the array is returned.
        //! Returns true if the node was pulled ok.
        bool pull_start_node(const std::string& name, bool& empty);

        //! Begin a new array at the current level in the tree
        //! Returns true if the array was pulled ok.
        bool pull_start_array(const std::string& name, bool& empty);

        //! End the current element -- node or array.
        //! Raises an exception if there is a mismatch.
        void pull_end_element(const std::string& name);

        //! Read a named attribute from the current node.
        //! Returns true if the attribute could be read, in which case its
        //! value is stored in the supplied reference
        //! Returns true if the attribute was pulled ok.
        bool read_attribute(const std::string& name, std::string& val);

        //! Read a named value from the current node.
        //! Returns true if the value could be read, in which case it is
        //! stored in the supplied reference
        //! Returns true if the value was pulled ok.
        bool read_value(const std::string& name, std::string& val);
        bool read_value(const std::string& name, unsigned& val);
        bool read_value(const std::string& name, double& val);
        bool read_value(const std::string& name, bool& val);


        // OUTPUT METHODS (not part of the 'serialization_writer interface'; this is implementation dependent)


        //! Extract contents of this stack as a string
        const std::string get_contents() const;


      protected:
        root_node root;

        // we maintain a stack of nodes representing our current
        // position within the serialization tree -- one for push, one for pull
        // the current node is at the top of the stack.
        // It is initialized to be the 'root' field above by the constructor

        // note that we have to use std::reference_wrapper, because
        // the STL container classes can't ordinarily take references
        std::list< std::reference_wrapper<basic_node> > push_stack;
        std::list< std::reference_wrapper<basic_node> > pull_stack;
	    };


    // push: create a new node at the current level
    void json_serialization_stack::push_start_node(const std::string& name, bool empty)
	    {
        if(this->push_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTY << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and push the new node to its contents
        // then, make the new node the current front-of-stack one
        std::reference_wrapper<basic_node> n = this->push_stack.front();

        // get front-of-stack node to synthesize a new element.
        // if it is a user_node, this will be another user_node.
        // if it is an array, it will be a root_node.
        json_serialization_stack::basic_node node = n.get().make_element(name, empty);

        n.get().push_content(node);
        this->push_stack.push_front(node);
	    }


    // pull: read a new node at the current level
    bool json_serialization_stack::pull_start_node(const std::string& name, bool& empty)
	    {
        bool rval = false;

		    if(this->pull_stack.size() == 0)
			    {
		        std::ostringstream msg;
				    msg << __CPP_TRANSPORT_SERIAL_PULLEMPTY << name << "'";
				    throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
			    }

		    // get reference to front-of-stack node, and check whether it can service this request
		    // note, if the top-of-stack item is an array then it will ignore names when we
		    // make the enquiry
        std::reference_wrapper<basic_node> n = this->pull_stack.front();

		    element nullele(""); // reference wrapper has to be bound to something initially; this is just a placeholder
        std::reference_wrapper<element> ele(nullele);

		    // if successful, push the node we have just pulled to the top of the pull stack
		    if((rval = n.get().pull_content(node, name, ele)))
			    {
				    // cast element up to basic_node; will throw an exception if this isn't possible
		        std::reference_wrapper<basic_node> node = std::reference_wrapper<basic_node>(dynamic_cast<basic_node&>(ele));
				    this->pull_stack.push_front(node);
			    }

        return(rval);
	    }


    // push: create a new array
    void json_serialization_stack::push_start_array(const std::string& name, bool empty)
	    {

        if(this->push_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTY << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and push the new node to its contents
        // then, make the new node the current front-of-stack one
        std::reference_wrapper<basic_node> n = this->push_stack.front();

        // make a new array element; both arrays and nodes can have these as members, so
        // no need to distinguish here
        json_serialization_stack::user_array array(name, empty);

        n.get().push_content(array);
        this->push_stack.push_front(array);
	    }


    // pull: read a new array at the current level
    bool json_serialization_stack::pull_start_array(const std::string& name, bool& empty)
	    {
        bool rval = false;

        if(this->pull_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PULLEMPTY << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and check whether it can service this request
        std::reference_wrapper<basic_node> n = this->pull_stack.front();

        element nullele(""); // reference wrapper has to be bound to something initially; this is just a placeholder
        std::reference_wrapper<element> ele(nullele);

        // if successful, push the node we have just pulled to the top of the pull stack
        if((rval = n.get().pull_content(array, name, ele)))
	        {
            // cast element up to basic_node; will throw an exception if this isn't possible
            std::reference_wrapper<basic_node> node = std::reference_wrapper<basic_node>(dynamic_cast<basic_node&>(ele));
            this->pull_stack.push_front(node);
	        }

        return(rval);
	    }


    // push: end the current node
    void json_serialization_stack::push_end_element(const std::string& name)
	    {
        // can't end the node if it is the root one
        if(this->push_stack.size() == 1)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_ENDNODE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get current front-of-stack node, and check that its name matches the
        // one we have been given; if not raise an error
        std::reference_wrapper<basic_node> n = this->push_stack.front();
        if(n.get().get_name() != name)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_ENDNAME_A << n.get().get_name() << __CPP_TRANSPORT_SERIAL_ENDNAME_B << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // validate this element
        if(!n.get().validate())
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_VALIDATE_FAIL << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // pop current front-of-stack node, reverting to whatever was on the stack previously
        this->push_stack.pop_front();
	    }


		// pull: end the current node
		void json_serialization_stack::pull_end_element(const std::string& name)
			{
				// can't end the node if it is the root one
				if(this->pull_stack.size() == 1)
					{
				    std::ostringstream msg;
						msg << __CPP_TRANSPORT_SERIAL_ENDNODE << name << "'";
						throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
					}

				// get current front-of-stack node, and check that its name matches the
				// one we have been given; if not, raise an error
		    std::reference_wrapper<basic_node> n = this->pull_stack.front();
				if(n.get().get_name() != name)
					{
				    std::ostringstream msg;
						msg << __CPP_TRANSPORT_SERIAL_ENDNAME_A << n.get().get_name() << __CPP_TRANSPORT_SERIAL_ENDNAME_B << name << "'";
						throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
					}

				// pop current front-of-stack node, reverting to whatever was on the stack previously
				this->pull_stack.pop_front();
			}


    // push: write attributes to the current node
    void json_serialization_stack::write_attribute(const std::string& name, const std::string& value)
	    {
        json_serialization_stack::value_element<std::string> ele(name, value);

        if(this->push_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTYATTR << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this attribute to it
        std::reference_wrapper<basic_node> n = this->push_stack.front();
        n.get().push_attribute(ele);
	    }


		// pull: read attributes from the current node
		bool json_serialization_stack::read_attribute(const std::string& name, std::string& val)
			{
		    bool rval = false;

		    if(this->pull_stack.size() == 0)
			    {
		        std::ostringstream msg;
		        msg << __CPP_TRANSPORT_SERIAL_PULLEMPTYATTR << name << "'";
		        throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
			    }

		    // get reference to front-of-stack node, and check whether it can service this request
		    std::reference_wrapper<basic_node> n = this->pull_stack.front();

		    element nullele(""); // reference wrapper has to be bound to something initially; this is just a placeholder
		    std::reference_wrapper<element> ele(nullele);

		    // if successful, extract
		    if((rval = n.get().pull_attribute(value, name, ele)))
			    {
		        // cast element up to value_element; will throw an exception if this isn't possible
		        std::reference_wrapper<value_element> value = std::reference_wrapper<value_element>(dynamic_cast<value_element&>(ele));
				    val = value.get().get_string();
			    }

				return(rval);
			}


    // Push: Write values to the current node
    //   There are specializations of this function for strings, unsigned integers, doubles and booleans


    void json_serialization_stack::write_value(const std::string& name, const std::string& value)
	    {
        json_serialization_stack::value_element<std::string> ele(name, value);

        if(this->push_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this value to its contents
        std::reference_wrapper<basic_node> n = this->push_stack.front();
        n.get().push_content(ele);
	    }


    void json_serialization_stack::write_value(const std::string& name, unsigned int value)
	    {
        json_serialization_stack::value_element<unsigned int> ele(name, value);

        if(this->push_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this value to its contents
        std::reference_wrapper<basic_node> n = this->push_stack.front();
        n.get().push_content(ele);
	    }


    void json_serialization_stack::write_value(const std::string& name, double value)
	    {
        json_serialization_stack::value_element<double> ele(name, value);

        if(this->push_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this value to its contents
        std::reference_wrapper<basic_node> n = this->push_stack.front();
        n.get().push_content(ele);
	    }


    void json_serialization_stack::write_value(const std::string& name, bool value)
	    {
        json_serialization_stack::value_element<bool> ele(name, value);

        if(this->push_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PUSHEMPTYVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this value to its contents
        std::reference_wrapper<basic_node> n = this->push_stack.front();
        n.get().push_content(ele);
	    }


		// Pull: Read values from the current node
    //   There are specializations of this function for strings, unsigned integers, doubles and booleans


    bool json_serialization_stack::read_value(const std::string& name, std::string& val)
	    {
        bool rval = false;

        if(this->pull_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PULLEMPTYATTR << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and check whether it can service this request
        std::reference_wrapper<basic_node> n = this->pull_stack.front();

        element nullele(""); // reference wrapper has to be bound to something initially; this is just a placeholder
        std::reference_wrapper<element> ele(nullele);

        // if successful, extract
        if((rval = n.get().pull_content(value, name, ele)))
	        {
            // cast element up to value_element; will throw an exception if this isn't possible
            std::reference_wrapper<value_element> value = std::reference_wrapper<value_element>(dynamic_cast<value_element&>(ele));
            val = value.get().get_string();
	        }

        return(rval);
	    }


    bool json_serialization_stack::read_value(const std::string& name, unsigned int& val)
	    {
        bool rval = false;

        if(this->pull_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PULLEMPTYATTR << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and check whether it can service this request
        std::reference_wrapper<basic_node> n = this->pull_stack.front();

        element nullele(""); // reference wrapper has to be bound to something initially; this is just a placeholder
        std::reference_wrapper<element> ele(nullele);

        // if successful, extract
        if((rval = n.get().pull_content(value, name, ele)))
	        {
            // cast element up to value_element; will throw an exception if this isn't possible
            std::reference_wrapper<value_element> value = std::reference_wrapper<value_element>(dynamic_cast<value_element&>(ele));
            val = value.get().get_unsigned_int();
	        }

        return(rval);
	    }


    bool json_serialization_stack::read_value(const std::string& name, double& val)
	    {
        bool rval = false;

        if(this->pull_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PULLEMPTYATTR << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and check whether it can service this request
        std::reference_wrapper<basic_node> n = this->pull_stack.front();

        element nullele(""); // reference wrapper has to be bound to something initially; this is just a placeholder
        std::reference_wrapper<element> ele(nullele);

        // if successful, extract
        if((rval = n.get().pull_content(value, name, ele)))
	        {
            // cast element up to value_element; will throw an exception if this isn't possible
            std::reference_wrapper<value_element> value = std::reference_wrapper<value_element>(dynamic_cast<value_element&>(ele));
            val = value.get().get_double();
	        }

        return(rval);
	    }


    bool json_serialization_stack::read_value(const std::string& name, bool& val)
	    {
        bool rval = false;

        if(this->pull_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_PULLEMPTYATTR << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to front-of-stack node, and check whether it can service this request
        std::reference_wrapper<basic_node> n = this->pull_stack.front();

        element nullele(""); // reference wrapper has to be bound to something initially; this is just a placeholder
        std::reference_wrapper<element> ele(nullele);

        // if successful, extract
        if((rval = n.get().pull_content(value, name, ele)))
	        {
            // cast element up to value_element; will throw an exception if this isn't possible
            std::reference_wrapper<value_element> value = std::reference_wrapper<value_element>(dynamic_cast<value_element&>(ele));
            val = value.get().get_bool();
	        }

        return(rval);
	    }


    // Reset head off the pull stack, and mark all items as unread
    void json_serialization_stack::pull_reset_head()
	    {
        // empty pull stack, and then push root node back to it
        this->pull_stack.clear();
        this->pull_stack.push_front(std::ref(static_cast<basic_node>(this->root)));

        // mark all items unread, recursively, from the root
        this->root.set_unread();
	    }


    // Reset read status, leaving the pull stack intact.
    // Works either from the current position on the stack or the root of the tree
    void json_serialization_stack::pull_reset_unread(json_serialization_stack::position pos)
	    {
        switch(pos)
	        {
            case json_serialization_stack::head:
	            this->root.set_unread();
            break;

            case json_serialization_stack::current:
	            std::reference_wrapper<basic_node> n = this->pull_stack.front();
	            n.get().set_unread();
            break;

            default:
	            assert(false);
	        }
	    }


    // Extract stringized contents of this serialization_writer
    const std::string json_serialization_stack::get_contents() const
	    {
        std::string output;

        // ensure top-of-stack object is the root node
        if(this->push_stack.size() != 1)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_NOT_FINISHED;
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        output = this->root.stringize();

        return(output);
	    }

	}   // namespace transport


#endif //__json_serialization_stack_H_
