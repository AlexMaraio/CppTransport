//
// Created by David Seery on 25/04/2014.
// Copyright (c) 2014 University of Sussex. All rights reserved.
//


#ifndef __unqlite_serializable_H_
#define __unqlite_serializable_H_


#include "transport-runtime-api/exceptions.h"
#include "transport-runtime-api/messages.h"

#include "transport-runtime-api/manager/serializable.h"

#include "boost/lexical_cast.hpp"


#define __UNQLITE_SERIALIZABLE_ROOT_NODE "root"


namespace transport
	{

		//! implements an UnQLite version of the serialization_writer interface

    class unqlite_serialization_writer: public serialization_writer
	    {
      protected:

		    // set up an abstract class hierarchy representing the
		    // elements of which the serialization is composed.
		    // 'element' is the basic abstract type
		    //   'nodes' are elements which may have attributes and contents. It is an abstract type
		    //     'user_node' is the typical node generated by a class performing serialization.
		    //     'root_node' is a special node type representing the base of the serialization tree.
		    //       root nodes stringize slightly differently, but are otherwise the same as user_nodes

        class element
	        {
          public:
            std::string name;

            // create a virtual destructor to ensure destructors for derived classes get called
            virtual ~element()
              {
              }

		        // 'attribute' marks that this element is an attribute
		        // it's up to the attribute element whether it uses this information
		        // at present, it is used to map XML-style attributes
		        // to a '@' tag for JSON fields
            virtual std::string stringize(bool attribute=false) const = 0;
	        };

        class basic_node: public element
	        {
          public:

            std::list<element> attributes;

            bool               empty;

            std::list<element> contents;

            virtual ~basic_node()
              {
              }
	        };

		    class user_node: public basic_node
			    {
          public:

		        //! Stringize this user_node for serialization to UnQLite's JSON document interface

            std::string stringize(bool attribute=false) const
	            {
                std::string r;

                if(this->empty)
	                {
                    r = this->name + ": ";
	                }
                else
	                {
                    r = this->name + ": { ";

                    for(std::list<element>::iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
	                    {
                        if(t != this->attributes.begin())
	                        {
                            r += std::string(", ");

		                        r += (*t).stringize(true);    // mark this element as an attribute
	                        }
	                    }

		                for(std::list<element>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
			                {
				                if(t != this->contents.begin())
					                {
				                    r += std::string(", ");

				                    r += (*t).stringize();
					                }
			                }

                    r += " }";
	                }

                return(r);
	            }
	        };

        class user_array: public basic_node
          {
          public:

            //! Stringize this user_array for serialization to UnQLite's JSON document interface

            std::string stringize(bool attribute=false) const
              {
                std::string r;

                if(this->empty)
                  {
                    r = this->name + ": []";
                  }
                else
                  {
                    r = this->name + ": [ ";


                    for(std::list<element>::iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
                      {
                        if(t != this->attributes.begin())
                          {
                            r += std::string(", ");

                            r += (*t).stringize(true);    // mark this element as an attribute
                          }
                      }

                    for(std::list<element>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
                      {
                        if(t != this->contents.begin())
                          {
                            r += std::string(", ");

                            r += (*t).stringize();
                          }
                      }

                    r += " ]";
                  }

                return(r);
              }

          };

        class root_node: public basic_node
	        {
          public:

            //! Stringize this root_node for serialization to UnQLite's JSON document interface.
		        //! root_node stringizes like user_node, except that we don't generate a field name and a value,
		        //! only a group of JSON fields surrounded by { ... }

            std::string stringize(bool attribute=false) const
	            {
                std::string r = "{ ";

                for(std::list<element>::iterator t = this->attributes.begin(); t != this->attributes.end(); t++)
                  {
                    if(t != this->attributes.begin())
                      {
                        r += std::string(", ");

		                    r += (*t).stringize();
                      }
                  }

                for(std::list<element>::iterator t = this->contents.begin(); t != this->contents.end(); t++)
	                {
                    if(t != this->contents.begin())
	                    {
                        r += std::string(", ");

                        r += (*t).stringize();
	                    }
	                }

                r += " }";

		            return(r);
	            }
	        };


		    template <typename T>
        class value_element: public element
	        {
          public:

		        //! Stored value
            T value;

		        //! Stringize the value stored in this element for serialization to UnQLite's JSON document interface

            std::string stringize(bool attribute=false) const
	            {
                std::string v = boost::lexical_cast<std::string>(this->value);

                return((attribute ? std::string("@") : std::string("")) + this->name + ": " + this->value);
	            }
	        };

      public:

		    //! create an unqlite_serialization_writer object

		    unqlite_serialization_writer()
			    {
				    // fill in details of the root node
				    this->root.name  = __UNQLITE_SERIALIZABLE_ROOT_NODE;
				    this->root.empty = false;

				    // push the root node onto the current stack
				    this->node_stack.push_front(std::ref(static_cast<basic_node>(this->root)));
			    }

        //! destructor
        ~unqlite_serialization_writer()
	        {
	        }


        // WRITING METHODS (implements a 'serialization writer' interface)


        //! Begin a new node at the current level in the tree
        void start_node(const std::string& name, bool empty=false);

        //! End the current node
        void end_node(const std::string& name);

        //! Begin a new array at the current level in the tree
        virtual void start_array(const std::string& name, bool empty=false) = 0;

        //! End the current array
        virtual void end_array(const std::string& name) = 0;

        //! Write attributes to the current node
        void write_attribute(const std::string& name, const std::string& value);

        //! Write a value
        void write_value(const std::string& name, const std::string& value);
        void write_value(const std::string& name, unsigned value);
        void write_value(const std::string& name, double value);
        void write_value(const std::string& name, bool value);


        // OUTPUT METHODS (not part of the 'serialization_writer interface'; this is implementation dependent)


        //! Extract contents of this serialization_writer as a string
        const std::string get_contents() const;


      protected:
		    root_node root;

		    // maintain a stack of nodes representing the serialization tree
		    // the current node is at the top of the stack.
		    // It is initialized to be the 'root' field above by the constructor

		    // note that we have to use std::reference_wrapper, because
		    // the STL container classes can't ordinarily take references
		    std::list< std::reference_wrapper<basic_node> > node_stack;
	    };


    // create a new node
    void unqlite_serialization_writer::start_node(const std::string& name, bool empty)
	    {
        unqlite_serialization_writer::user_node node;

        node.name       = name;
        node.empty      = empty;

				if(this->node_stack.size() == 0)
					{
				    std::ostringstream msg;
						msg << __CPP_TRANSPORT_SERIAL_NONODE << name << "'";
						throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
					}

		    // get reference to front-of-stack node, and push the new node to its contents
		    // then, make the new node the current front-of-stack one
        std::reference_wrapper<basic_node> n = this->node_stack.front();
        n.get().contents.push_back(node);
		    this->node_stack.push_front(node);
	    }


		// end the current node
		void unqlite_serialization_writer::end_node(const std::string& name)
			{
        // can't end the node if it is the root one
				if(this->node_stack.size() == 1)
					{
				    std::ostringstream msg;
						msg << __CPP_TRANSPORT_SERIAL_ENDNODE << name << "'";
				    throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
					}

				// get current front-of-stack node, and check that its name matches the
				// one we have been given; if not raise an error
		    std::reference_wrapper<basic_node> n = this->node_stack.front();
				if(n.get().name != name)
					{
				    std::ostringstream msg;
						msg << __CPP_TRANSPORT_SERIAL_ENDNAME_A << n.get().name << __CPP_TRANSPORT_SERIAL_ENDNAME_B << name << "'";
						throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
					}

        // was this node supposed to be empty? if so, check that it is
        if(n.get().empty && n.get().contents.size() > 0)
          {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_NOT_EMPTY << " '" << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
          }
        else if(!n.get().empty() && n.get().contents.size() == 0)
          {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_IS_EMPTY << " '" << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
          }

				// pop current front-of-stack node, reverting to whatever was on the stack previously
				this->node_stack.pop_front();
			}


		// write attributes to the current node
		void unqlite_serialization_writer::write_attribute(const std::string& name, const std::string& value)
			{
				value_element<std::string> ele;

				ele.name  = name;
				ele.value = value;

				if(this->node_stack.size() == 0)
					{
				    std::ostringstream msg;
						msg << __CPP_TRANSPORT_SERIAL_NONODEATTR << name << "'";
						throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
					}

				// get reference to current front-of-stack node, and push this attribute to it
		    std::reference_wrapper<basic_node> n = this->node_stack.front();
				n.get().attributes.push_back(ele);
			}


		// Write values to the current node
		//   There are specializations of this function for strings, unsigned integers, doubles and booleans

		void unqlite_serialization_writer::write_value(const std::string& name, const std::string& value)
			{
				value_element<std::string> ele;

				ele.name  = name;
				ele.value = value;

		    if(this->node_stack.size() == 0)
			    {
		        std::ostringstream msg;
		        msg << __CPP_TRANSPORT_SERIAL_NONODEVALUE << name << "'";
		        throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
			    }

				// get reference to current front-of-stack node, and push this value to its contents
		    std::reference_wrapper<basic_node> n = this->node_stack.front();
				n.get().contents.push_back(ele);
			}

    void unqlite_serialization_writer::write_value(const std::string& name, unsigned int value)
	    {
        value_element<unsigned int> ele;

        ele.name  = name;
        ele.value = value;

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_NONODEVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this value to its contents
        std::reference_wrapper<basic_node> n = this->node_stack.front();
        n.get().contents.push_back(ele);
	    }

    void unqlite_serialization_writer::write_value(const std::string& name, double value)
	    {
        value_element<double> ele;

        ele.name  = name;
        ele.value = value;

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_NONODEVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this value to its contents
        std::reference_wrapper<basic_node> n = this->node_stack.front();
        n.get().contents.push_back(ele);
	    }

    void unqlite_serialization_writer::write_value(const std::string& name, bool value)
	    {
        value_element<bool> ele;

        ele.name  = name;
        ele.value = value;

        if(this->node_stack.size() == 0)
	        {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_NONODEVALUE << name << "'";
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
	        }

        // get reference to current front-of-stack node, and push this value to its contents
        std::reference_wrapper<basic_node> n = this->node_stack.front();
        n.get().contents.push_back(ele);
	    }


    // Extract contents of this serialization_writer
    const std::string unqlite_serialization_writer::get_contents() const
      {
        std::string output;

        // ensure top-of-stack object is the root node
        if(this->node_stack.size() != 1)
          {
            std::ostringstream msg;
            msg << __CPP_TRANSPORT_SERIAL_NOT_FINISHED;
            throw runtime_exception(runtime_exception::SERIALIZATION_ERROR, msg.str());
          }

        output = this->root.stringize();

        return(output);
      }

	}



#endif //__unqlite_serializable_H_
